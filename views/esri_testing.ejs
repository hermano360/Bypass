<!DOCTYPE html>
<html class="no-js" lang="en" dir="ltr">
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="initial-scale=1, maximum-scale=1,user-scalable=no">
  <title>Bypass</title>

  <link rel="stylesheet" href="stylesheets/foundation.min.css" />
  <link rel="stylesheet" href="stylesheets/app.css" />
  <link rel="stylesheet" href="https://js.arcgis.com/3.17/dijit/themes/claro/claro.css">
  <link rel="stylesheet" href="https://js.arcgis.com/3.17/esri/css/esri.css">

  <script type="text/javascript">
    var dojoConfig = {
      parseOnLoad: true
    };
  </script>

  <script src="javascripts/jquery-2.2.2.min.js"></script>
  <script src="https://js.arcgis.com/3.17/"></script>
  <script src="javascripts/foundation.js"></script>
  <script src="javascripts/what-input.js"></script>

  <script>
    require( [
      "esri/urlUtils",
      "esri/config",
      "esri/map",
      "esri/graphic",
      "esri/dijit/Search",
      "esri/IdentityManager",
      "esri/tasks/RouteTask",
      "esri/tasks/RouteParameters",
      "esri/tasks/RouteResult",
      "esri/tasks/FeatureSet",
      "esri/symbols/SimpleMarkerSymbol",
      "esri/symbols/SimpleLineSymbol",
      "esri/symbols/SimpleFillSymbol",
      "esri/geometry/Polyline",
      "esri/Color",
      "dojo/_base/array",
      "dojo/on",
      "dojo/dom",
      "dijit/registry",
      "dojo/query",
      "esri/geometry/webMercatorUtils",
      "esri/geometry/Circle",
      "esri/geometry/Point",
      "dojo/request",
      "dojo/request/xhr",
      "dojo/ready",
      "esri/tasks/geometry",
      "esri/units",
      "dijit/layout/BorderContainer",
      "dijit/layout/ContentPane",
      "dijit/form/HorizontalSlider",
      "dijit/form/HorizontalRuleLabels"
      ], function (
        urlUtils, esriConfig, Map, Graphic, Search, esriId, RouteTask, RouteParameters, RouteResult,
        FeatureSet, SimpleMarkerSymbol, SimpleLineSymbol, SimpleFillSymbol, Polyline,
        Color, array, on, dom, registry, djQuery, webMercatorUtils, Circle, Point, request, xhr,ready
        )
      {
        var data = [
        // this is the format of the data we are accepting "Trespassing",-118.5006528,34.01718056,3
        ];

        var map, routeTask, routeParams, routeParamsNormal, routes = [];
        var barriers = [], routeStops = [{},{}], myLocation = [];
        var irreleventBarriers = [];
        var stopSymbol, barrierSymbol, barrierSymbol1, customRouteSymbol, routeSymbols, polygonBarrierSymbol;
        var mapOnClick_addStops_connect, mapOnClick_addBarriers_connect, mapOnClick_addPolygonBarriers_connect, mapOnClick_testCrime_connect, mapOnClick_mapIndex_connect, myLocationToAddress_connect;
        var stopCounter = 0;
        var barrierToggle = 0;
        var sortedData;
        var plotCount = 0;
        var routeResults;
        var formatedData;
        var crimeArray = [];
        var globalxydata;
        var severityAll = [];
        var densityArray;
        var weightedSpatialArray;
        var phoneNumber;
        var businessLocations;
        var footTrafficArray;
        var globalToken;
        var sRoute;
        var irreleventBarriersLimit=0;
        var densityGridOn = true;
        var routeCheckerStop;
        var barrierVisibility = false;
        var sRouteWB;
        var normalRoute;
        var bypassRoute;
        var chosenRouteDirections;
        var normalRouteDirections;
        var bypassRouteDirections;

        var myLocationAddress;
        var whichStopAddressInput;

        var walkModeUrl = "";
        //walkModeUrl = "travelMode={\"paramName\": \"defaultTravelMode\",\"dataType\": \"GPString\",\"value\": \"caFAgoThrvUpkFBW\"}&"

        var SantaMonicaCoordinates= {
          xmin:-13193161.542197285, //western-most x-coordinate (corresponds to GPS)
          xmax:-13185441.402340494, //eastern-most x-coordinate (corresponds to GPS)
          ymax:4035246.5784217017,  //northern-most y-coordinate (corresponds to GPS)
          ymin:4028520.119932615,  //southern-most y-coordinate (corresponds to GPS)
          blockWidthXY: 187.02, //This is what correponds most closely to about 300' in terms of xy coordinates
        }

        //  urlUtils.addProxyRule({
        //  urlPrefix: "route.arcgis.com",
        //  proxyUrl: "/sproxy/"
        // });

        map = new Map("map", {
          basemap: "streets",
          center: [-118.49132, 34.01455],
          zoom: 14,
          smartNavigation: false //by adding this, the scroll mouse goes in and out, rather than up and down. perhaps the other way is better though, idk.
        });

        function resetBarriers(){
          if(densityGridOn){
            clearBarriers();
            mapAllIndices(densityArray);
          }
        }

        ready(function() {
          xhr.get("cached_danger_influences.csv", { //uploading csv data
            handleAs: "text",
          }).then(function(data) {
            globalvariable = data.replace(/\n/g, "," ).split(",");
            formatedData = formatGlobal(globalvariable);
            densityArray = dangerAlgorithm(formatedData);
            mapAllIndices(densityArray);
            on(map, "extent-change", resetBarriers);
          });

          xhr.get("SMpopdataFormat1.csv", {
            handleAs: "text",
          }).then(function(data) {

            businessLocations = formatBusinesses(data.split(","));

            footTrafficArray = dangerAlgorithm(businessLocations);
          });

          $("#directionsButton").click( function () {
            if ($('#directionsDisplay').text().length != 0 ) {
              $('#directionsDisplay').empty();
            }
            else {
              var border_style = "";
              for(var i = 1 ; i < chosenRouteDirections[0].features.length; i++)
              {
                if (i != chosenRouteDirections[0].features.length)
                {
                  border_style = " style='border-bottom: 1px solid #BBBBBB' ";
                }
                else
                {
                  border_style = ""
                }

                $("#directionsDisplay").append("<div class='row'" + border_style + "><div class='large-12 columns dynamicDirectionsRow'>" + chosenRouteDirections[0].features[i].attributes.text + "</div></div>");
              };
            }
          });

          $("#addStopsBtn").click( function () {
            addStops();
          });

          $("#solveRoute").click( function(){
            if($('#solveRoute').val()==="Go!"){
              $('#solveRoute').css("display","none");
              $('#solveRoute').val("Solve!");
              if(routes.length > 1){
                map.graphics.remove(routes.shift());
              }

              $("#BypassRoute").css('display',"none");
              $("#NormalRoute").css('display',"none");

            } else{
              clearStops();
              clearRoutes();
              routeStops = [{},{}];
              routeCheckerStop = [0,0];
              requestAddress($('#startAddress').val(),"start");
              requestAddress($('#destinationAddress').val(),"end");
            }
          })

          $("#addBarriersBtn").click( function () {
            if(barrierToggle==0) {
              $(this).css('background','orange');
              addBarriers();
              barrierToggle=1;
            } else if(barrierToggle ==1) {
              $(this).css('background','rgba(0,0,0, 0.3)');
              removeEventHandlers();
              barrierToggle=0;
            }
          });
          //need to add fix this section to reflect the functionality goals
          $('#startAddress').click(function() {
            whichStopAddressInput = "start";
            addStartStop();

          });

          $('#destinationAddress').click(function() {
            whichStopAddressInput = "end";
            addDestinationStop();
          });

          $('#startAddress').keyup(function(){
            if($('#startAddress').val() && $('#destinationAddress').val()){
              $('#solveRoute').css('display',"inline");
            }
          });

         $('#destinationAddress').keyup(function(){
            if($('#startAddress').val() && $('#destinationAddress').val()){
              $('#solveRoute').css('display',"inline");
            }
          });

          $('#cancel').click(function() {
            removeEventHandlers();
          });

          $('#myLocation').click(function() {
            addMyLocationDot();
          });

          $("#clearRoutesBtn").click( function () {
            clearStops();
            clearBarriers();
            clearRoutes();
            $('#startAddress').val("");
            $('#destinationAddress').val("");
            $('#solveRoute').css("display","none");
            barrierVisibility = false;
            mapAllIndices(densityArray);
          });

          $("#bufferzone").click( function () {
            showBufferZones(sortedData);
          });

          $("#BypassRoute").click(function () {
            chooseBypass();
            console.log(routes.length);
          });

          $("#NormalRoute").click( function () {
            chooseNormal();
          });

          $("#streetlights").click( function() {
            //console.log(routeParams.returnDirections);
            //console.log(routeParams);
            mapAllIndices(footTrafficArray);
          });

          $("#mapCrimeIndex").click( function () {
            mapIndex();
          });

          $("#DensityGrid").click( function () {
            barrierVisibility = !barrierVisibility;
            clearBarriers();
            mapAllIndices(densityArray);
          });

          $("#ClusterGrid").click( function () {
            weightedSpatialArray = crimeCluster(formatedData);
            mapAllIndices(weightedSpatialArray);
          });
        });

//The globalvariable below is only going to be available after ajax request is successful.
    //HPE Data upload
    var objectdata = {apikey : "385bcd30-9d17-4037-917f-442c08e82b78", file : "/../public/SMCrimeBeatData.csv"/*"https://drive.google.com/uc?export=download&id=0BxioPUqqdZqReExzdWZYc2tfZFE"*/, max_results: 5, columns: ["Call_Type","Location"]}
// $.ajax({
//         url: "https://api.havenondemand.com/1/api/sync/anomalydetection/v1",
//         type: 'POST',
//         dataType: 'json',
//         async: false,
//         data: objectdata,
//         success: function (results, textStatus, xhr) {
//           console.log("test passed");
//           console.log(results);
//           // for(var i; i< results.length; i++){
//           //   console.log(results[i]);
//           // }
//         },
//         error: function (xhr, textStatus, errorThrown) {
//             console.log("test failed");
//             console.log("ERROR:" + xhr.responseText + xhr.status + errorThrown);

//             return false;
//         }
//     });

function phoneStore() {
	if(phoneNumber){
		alert("Calling " + phoneNumber + "...");
	} else {
		phoneNumber = prompt("Please enter an emergency phone number","");
	}
}
function filterBySeverity(data) {
  var sortCounter = 0;
  var filteredData = [];
  var currentSeverity = $("input[name=routeRadioButtons]:checked").val();
  var bufferSeverity;
  if(currentSeverity == "Route 1"){
    bufferSeverity = 1;
  } else if(currentSeverity == "Route 2"){
    bufferSeverity = 2;
  } else if(currentSeverity == "Route 3"){
    bufferSeverity = 3;
  }

  for(var i = 4; i < data.length; i += 4){
    if(data[i+3]==bufferSeverity){
      filteredData[sortCounter] = data[i];
      filteredData[sortCounter+1] = Number(data[i+1]);
      filteredData[sortCounter+2] = Number(data[i+2]);
      filteredData[sortCounter+3] = Number(data[i+3]);
      sortCounter += 4;
    }
  }
  return filteredData;
}

function requestAddress(givenAddress,stopOption){
  var xCoord = 0;
  var yCoord = 0;

  var finalGeocodingURL = "http://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/geocodeAddresses?addresses={%22records%22:[{%22attributes%22:{%22OBJECTID%22:1,%22SingleLine%22:%22" + givenAddress.replace(" ","%20") + "%22}}]}&sourceCountry=USA&token=" + globalToken + "&f=pjson";

  var finalResults;
            $.ajax({
            type: 'POST',
            url: finalGeocodingURL,
            success: function (results, textStatus, xhr) {

              finalResults = JSON.parse(results);
              xCoord = finalResults.locations[0].location.x;
              yCoord = finalResults.locations[0].location.y;

              console.log(stopOption,xCoord,yCoord);

              var instancePoint = new Point(xCoord,yCoord);

              if(stopOption == "end") {
                map.graphics.remove(routeStops.pop());
                routeStops.push(map.graphics.add(new esri.Graphic(instancePoint,stopSymbol)));
                routeCheckerStop[1]=1;

              } else if(stopOption == "start"){
                map.graphics.remove(routeStops.shift());
                routeStops.unshift(map.graphics.add(new esri.Graphic(instancePoint,startSymbol)));
                routeCheckerStop[0]=1
            }

            if(routeCheckerStop[0]&&routeCheckerStop[1]){
              solveRoute();
            }

            },
            error: function (xhr, textStatus, errorThrown) {
              console.log("test failed");
              console.log("ERROR:" + xhr.responseText + xhr.status + errorThrown);
              return false;
            }
          });

}

function formatGlobal(dataz) {
  var formatedglobal = [];
  var rowData = new Array(4);

  for(var k = 4; k < dataz.length-3; k = k+4){
    rowData[0] = dataz[k];
    rowData[1] = Number(dataz[k+1]);
    rowData[2] = Number(dataz[k+2]);
    rowData[3] = Number(dataz[k+3]);
    formatedglobal.push(rowData);
    rowData = [0,0,0,0];
  }

  return formatedglobal;
}

function formatBusinesses(dataz) {
	var formattedBusinessArray = [];
	var rowData = new Array(4);

	for(var k = 2; k < dataz.length-1; k = k+2){
		rowData[0] = dataz[k];
		rowData[1] = Number(dataz[k+1].match(/\((.*)\;/i)[1]);
		rowData[2] = Number(dataz[k+1].match(/\;(.*)\)/i)[1]);
		rowData[3] = 1;

		formattedBusinessArray.push(rowData);
		rowData = [0,0,0,0];
	}

  //console.log(formattedBusinessArray);
  return formattedBusinessArray;
}

var authdata = {client_id: '9gdUoBaoDjP5INej', client_secret: 'd2368d00106f46ec9e6d5bd9b069704a', grant_type: 'client_credentials', expiration: '1440'}
var authresults;

//synchronous
//https://route.arcgis.com/arcgis/rest/services/World/Route/NAServer/Route_World"

//asynchronous
//http://logistics.arcgis.com/arcgis/rest/services/World/Route/GPServer/FindRoutes/

$.ajax({
  type: 'POST',
  url: 'https://www.arcgis.com/sharing/rest/oauth2/token/',
  data: authdata,

  success: function (results, textStatus, xhr) {
    //console.log(results);
    var tokenObject = JSON.parse(results);
    globalToken = tokenObject.access_token;
    console.log(globalToken);
    var tokenParameters = {expires: (Date.now() + 86400).toString(),server:'https://route.arcgis.com/arcgis/rest/services/World/Route/NAServer/Route_World', ssl:true, token:tokenObject.access_token, userId:authdata.client_id};

    esriId.registerToken(tokenParameters);
  },

  error: function (xhr, textStatus, errorThrown) {
    console.log("test failed");
    console.log("ERROR:" + xhr.responseText + xhr.status + errorThrown);
    return false;
  }
});

//generate a token with your client id and client secret
// $.ajax({
//     url: 'https://www.arcgis.com/sharing/rest/oauth2/token/',
//     json: true,
//     form: {
//       'f': 'json',
//       'client_id': '9gdUoBaoDjP5INej',
//       'client_secret': 'd2368d00106f46ec9e6d5bd9b069704a',
//       'grant_type': 'client_credentials',
//       'expiration': '1440'
//     }
// }, function(error, response, body){
// console.log(error);
//     console.log(body.access_token);
// });
//spH-4ut_taI6YRCYqbz4a1KWiK9Psdy2HaDAcNcq3z3yhLy0BdhPovt0mNRis3DbZlxDaT0t633lZlqhNZvptV5YHkKw_dmY5b00Xp2b6k1EC452t0q2GV2olqlK3RZux1ROFGIWnTpePUz2FON0rg..
routeTask = new RouteTask("https://route.arcgis.com/arcgis/rest/services/World/Route/NAServer/Route_World");
routeParams = new RouteParameters();
routeParams.stops = new FeatureSet();
routeParams.barriers = new FeatureSet();
routeParams.polygonBarriers = new esri.tasks.FeatureSet();
routeParams.returnDirections = true;

polygonBarrierSymbol = new esri.symbol.SimpleFillSymbol();
customRouteSymbol = new SimpleLineSymbol();

routeParams.outSpatialReference = {"wkid":102100};
        //dojo.ready(function() { routeTask.on("solve-complete", showRoute); });
        routeTask.on("solve-complete", showRoute);
        routeTask.on("error", errorHandler);
        //used as the start symbol of a destination
        startSymbol = new SimpleMarkerSymbol();
        startSymbol.setAngle(0);
        startSymbol.setColor(new Color([38, 115, 0, 0.82]));
        startSymbol.setPath("M16,3.5c-4.142,0-7.5,3.358-7.5,7.5c0,4.143,7.5,18.121,7.5,18.121S23.5,15.143,23.5,11C23.5,6.858,20.143,3.5,16,3.5z M16,14.584c-1.979,0-3.584-1.604-3.584-3.584S14.021,7.416,16,7.416S19.584,9.021,19.584,11S17.979,14.584,16,14.584z");
        startSymbol.setStyle(SimpleMarkerSymbol.STYLE_PATH);
        //used as the end symbol of a destination
        stopSymbol = new SimpleMarkerSymbol();
        stopSymbol.setAngle(0);
        stopSymbol.setColor(new Color([230, 0, 0, 0.82]));
        stopSymbol.setPath("M16,3.5c-4.142,0-7.5,3.358-7.5,7.5c0,4.143,7.5,18.121,7.5,18.121S23.5,15.143,23.5,11C23.5,6.858,20.143,3.5,16,3.5z M16,14.584c-1.979,0-3.584-1.604-3.584-3.584S14.021,7.416,16,7.416S19.584,9.021,19.584,11S17.979,14.584,16,14.584z");
        stopSymbol.setStyle(SimpleMarkerSymbol.STYLE_PATH);
        barrierSymbol = new esri.symbol.PictureMarkerSymbol({
          "angle": 0,
          "xoffset": 0,
          "yoffset": 0,
          "type": "esriPMS",
          "url": "https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/ProhibitionSign2.svg/2000px-ProhibitionSign2.svg.png",
          "contentType": "image/png",
          "width": 15,
          "height": 15
        });
        var barrierSymbol1 = new SimpleFillSymbol().setColor(null).outline.setColor("blue");
        routeSymbols = {
          "Route 1": new SimpleLineSymbol().setColor(new Color([169,169,169,.75])).setWidth(5),
          "Route 2": new SimpleLineSymbol().setColor(new Color([140,212,204,1])).setWidth(5),
          "Route 3": new SimpleLineSymbol().setColor(new Color([255,0,255,0.5])).setWidth(5)
        };
        //button click event listeners can't be added directly in HTML when the code is wrapped in an AMD callback
        //using APIs?

        //on(dom.byId("addStopsBtn"), "click", addStops);
        //on(dom.byId("clearStopsBtn"), "click", clearStops);
        //on(dom.byId("addBarriersBtn"), "click", addBarriers);
        //on(dom.byId("clearBarriersBtn"), "click", clearBarriers);
        //on(dom.byId("solveRoutesBtn"), "click", solveRoute);
        //on(dom.byId("clearRoutesBtn"), "click", clearRoutes);
        //Begins listening for click events to add stop

        function inputAddress(){
          clearRoutes();
          $('#solveRoute').css("display","none");
          $('#solveRoute').val("Solve!");
         navigator.geolocation.getCurrentPosition(function(position){
              long = position.coords.longitude;
              lat = position.coords.latitude;
              centerpoint = new Point(long,lat);
              if(whichStopAddressInput == "start"){
                map.graphics.remove(routeStops.shift());
                routeStops.unshift(map.graphics.add(new esri.Graphic(centerpoint,startSymbol)));
              } else if(whichStopAddressInput == "end"){
                map.graphics.remove(routeStops.pop());
                routeStops.push(map.graphics.add(new esri.Graphic(centerpoint,stopSymbol)));
              }


              $.ajax({
                type: 'POST',
                url: "http://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/reverseGeocode?location="+long+"%2C+"+lat+"&distance=200&outSR=&f=pjson",
                success: function (results, textStatus, xhr) {
                  var parsedResults = JSON.parse(results);
                  if(whichStopAddressInput == "start"){
                    $("#startAddress").val(parsedResults.address.Match_addr);
                  } else if(whichStopAddressInput == "end"){
                    $("#destinationAddress").val(parsedResults.address.Match_addr);
                  }
                  $("#myLocation").off('click', inputAddress);

                  if($('#startAddress').val() && $('#destinationAddress').val()){
                    $('#solveRoute').css('display',"inline");
                  }
                },
                error: function (xhr, textStatus, errorThrown) {
                  console.log("test failed");
                  console.log("ERROR:" + xhr.responseText + xhr.status + errorThrown);
                  return false;
                }
              });


            });
        }


        function addStartStop(){
          removeEventHandlers();
          $('#solveRoute').css("display","none");
          $('#solveRoute').val("Solve!");

          $("#myLocation").on('click', inputAddress);
          mapOnClick_addStops_connect = map.on("click", function(evt){
            clearRoutes();
            map.graphics.remove(routeStops.shift());
            routeStops.unshift(map.graphics.add(new esri.Graphic(evt.mapPoint,startSymbol)));


            var longlat = webMercatorUtils.xyToLngLat(evt.mapPoint["x"], evt.mapPoint["y"], true);
            $.ajax({
            type: 'POST',
            url: "http://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/reverseGeocode?location="+longlat[0]+"%2C+"+longlat[1]+"&distance=200&outSR=&f=pjson",
            success: function (results, textStatus, xhr) {
              var parsedResults = JSON.parse(results);
              $("#startAddress").val(parsedResults.address.Match_addr);

              if($('#startAddress').val() && $('#destinationAddress').val()){
                $('#solveRoute').css('display',"inline");
              }

            },
            error: function (xhr, textStatus, errorThrown) {
              console.log("test failed");
              console.log("ERROR:" + xhr.responseText + xhr.status + errorThrown);
              return false;
            }
          });

removeEventHandlers();

          });

        }

        function addDestinationStop(){
          $('#solveRoute').css("display","none");
          $('#solveRoute').val("Solve!");
          removeEventHandlers();
          $("#myLocation").on('click', inputAddress);
          mapOnClick_addStops_connect = map.on("click", function(evt){
            clearRoutes();
            map.graphics.remove(routeStops.pop());
            routeStops.push(map.graphics.add(new esri.Graphic(evt.mapPoint,stopSymbol)));

            if($('#startAddress').val() && $('#destinationAddress').val()){
              $('#solveRoute').css('display',"inline");
            }
            var longlat = webMercatorUtils.xyToLngLat(evt.mapPoint["x"], evt.mapPoint["y"], true);
            $.ajax({
            type: 'POST',
            url: "http://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/reverseGeocode?location="+longlat[0]+"%2C+"+longlat[1]+"&distance=200&outSR=&f=pjson",
            success: function (results, textStatus, xhr) {
              var parsedResults = JSON.parse(results);
              $("#destinationAddress").val(parsedResults.address.Match_addr);
              if($('#startAddress').val() && $('#destinationAddress').val()){
                $('#solveRoute').css('display',"inline");
              }

            },
            error: function (xhr, textStatus, errorThrown) {
              console.log("test failed");
              console.log("ERROR:" + xhr.responseText + xhr.status + errorThrown);
              return false;
            }
          });

            removeEventHandlers();
          });
        }


        function addStops() {
          removeEventHandlers();
          var node = dom.byId("addStopsBtn");
          node.style.backgroundColor="green";
          node.innerHTML= "Click To Start and End!";
          mapOnClick_addStops_connect = map.on("click", addStop);
        }
        //Clears all stops
        function clearStops() {
          removeEventHandlers();
          for (var i=routeStops.length-1; i>=0; i--) {
            map.graphics.remove(routeStops.splice(i, 1)[0]);
          }
        }
        //Adds a stop. The stop is associated with the route currently displayed in the dropdown
        function addStop(evt) {
          //console.log($("input[name=routeRadioButtons]:checked").val())
          var node2 = dom.byId("addStopsBtn");
          node2.style.backgroundColor= "yellow";
          if (stopCounter == 0) {
            clearStops();
            clearRoutes();
            destinationSymbol = startSymbol;
            stopCounter = 1;
            addStops();
          } else {
            node2.innerHTML= "Click Here For New Route";
            node2.style.backgroundColor= "blue";
            destinationSymbol = stopSymbol;
            stopCounter = 0;
          }
          routeStops.push(
            map.graphics.add(
              new esri.Graphic(
                evt.mapPoint,
                destinationSymbol,
                { RouteName:$("input[name=routeRadioButtons]:checked").val() }
                )
              )
            );
          if (stopCounter == 0) {
            solveRoute();
          }
          //
          //console.log("addStop", evt.mapPoint);
        }
        //Begins listening for click events to add barriers
        function addBarriers() {
          removeEventHandlers();
          mapOnClick_addBarriers_connect = on(map, "click", addBarrier1); //change to addBarrier1 once process completed
        }

        function mapIndex() {
          mapOnClick_mapIndex_connect = on(map, "click", addAnIndex);
        }
        //Fast mode
        function clearBarriers() {
          removeEventHandlers();
          for (var i=barriers.length-1; i>=0; i--) {
            map.graphics.remove(barriers.splice(i, 1)[0]);
          }
          for (var i=irreleventBarriers.length-1; i>=0; i--) {
            map.graphics.remove(irreleventBarriers.splice(i, 1)[0]);
          }
          clearCircleBarrier();
        }
        //Adds a barrier
        function addBarrier(evt) {
          barriers.push(
            map.graphics.add(
              new esri.Graphic(
                evt.mapPoint,
                barrierSymbol
                )
              )
            );


          //
          //console.log("addBarrier", evt.mapPoint);
        }
        function addBarrier1(evt) {
          var latLongEvt = webMercatorUtils.xyToLngLat(evt.mapPoint["x"], evt.mapPoint["y"], true);
          var severityEvt = $("input[name=severityRadioButtons]:checked").val();
          addCircleBarrier1(latLongEvt[0],latLongEvt[1],severityEvt);

          /*
          barriers.push(
            map.graphics.add(
              new esri.Graphic(
                evt.mapPoint,
                barrierSymbol
                )
              )
            );
            */

          //
          //console.log("addBarrier1", evt.mapPoint);
        }


        function mapAllIndices(array) {
          var xcenter;
          var ycenter;
          var max = 0;
          for(var i = 0; i < array.length; i++){
            for(var j = 0; j < array[i].length; j++){
              if(array[i][j]>max){
                max = array[i][j];
              }
            }
          }


          for(var i = 0; i < array.length; i = i+1){
            for(var j = 0; j < array[i].length; j=j+1){
              xcenter = -118.51618659213699 + i * 0.001651218959260686;
              ycenter = 34.047981411250944 - j * 0.0013911360369712373;
              addSquareBarrier(xcenter,ycenter,max,array);
            }
          }
          console.log(barriers.length);
          console.log(irreleventBarriers.length);
        }

        function addMyLocationDot() {
          clearMyLocation();
          var long;
          var lat;
          var centerpoint;
          myLocationSymbol = new esri.symbol.PictureMarkerSymbol({
                "angle": 0,
                "xoffset": 0,
                "yoffset": 0,
                "type": "esriPMS",
                "url": "/images/myLocation.png",
                "contentType": "image/png",
                "width": 8,
                "height": 8
              });


            navigator.geolocation.getCurrentPosition(function(position){
              long = position.coords.longitude;
              lat = position.coords.latitude;
              centerpoint = new Point(long,lat);

              myLocation.push(map.graphics.add(new esri.Graphic(centerpoint,myLocationSymbol)));


              $.ajax({
                type: 'POST',
                url: "http://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/reverseGeocode?location="+long+"%2C+"+lat+"&distance=200&outSR=&f=pjson",
                success: function (results, textStatus, xhr) {
                  var parsedResults = JSON.parse(results);
                  //console.log(parsedResults.address.Match_addr);
                },
                error: function (xhr, textStatus, errorThrown) {
                  console.log("test failed");
                  console.log("ERROR:" + xhr.responseText + xhr.status + errorThrown);
                  return false;
                }
              });


            });

        }

        function clearMyLocation(){
            map.graphics.remove(myLocation.splice(0, 1)[0]);
        }

        function addSquareBarrier(long, lat,max,array) {
          //op as opacity, radius as radius

          var xdata = Math.round((long-(-118.51618659213699))/0.001651218959260686);

          var ydata = Math.round((34.047981411250944-lat)/0.0013911360369712373);

          var op = array[xdata][ydata]/max;
          var impedance = op*10;
          var outlineop;

          xcenter = -118.51618659213699 + xdata * 0.001651218959260686;
          ycenter = 34.047981411250944 - ydata * 0.0013911360369712373;

          //Change square outline
          if(impedance > 1){
            outlineop = .2
          } else{
            outlineop = 0;
          }

          if(!barrierVisibility){
            op = 0;
            outlineop = 0;
          }
          //Change square color
          polygonBarrierSymbol.setColor(new Color([255,0,0,op]));

          polygonBarrierSymbol.setOutline(new SimpleLineSymbol(esri.symbol.SimpleLineSymbol.STYLE_SOLID, new Color([255,0,0,outlineop]), 2));

          var center = new esri.geometry.Point([xcenter, ycenter]);

          var ring = []; // point that make up the circle


          ring.push([center.x - .5 * 0.001651218959260686 * .95, center.y + .5 * 0.0013911360369712373* .95]);
          ring.push([center.x + .5 * 0.001651218959260686* .95, center.y + .5 * 0.0013911360369712373* .95]);
          ring.push([center.x + .5 * 0.001651218959260686* .95, center.y - .5 * 0.0013911360369712373* .95]);
          ring.push([center.x - .5 * 0.001651218959260686* .95, center.y - .5 * 0.0013911360369712373* .95]);

          ring.push(ring[0]); // start point needs to == end point
          var square = new esri.geometry.Polygon(ring);
          var polygonbarrier = new esri.Graphic(square,polygonBarrierSymbol);
          polygonbarrier.attributes= {BarrierType: 1, Attr_TravelTime: impedance};


          if(impedance > 1){
            barriers.push(map.graphics.add(polygonbarrier));
          }else {
            irreleventBarriers.push(map.graphics.add(polygonbarrier));
          }
        }

       //Load-in barrier circle(polygon)
       function addCircleBarrier1(long, lat, severity) {
          //op as opacity, radius as radius
          var op, radius;
          if(severity == 1) {
            op = 0.15;
            radius = 0.0004;
          }
          else if(severity == 2) {
            op = 0.20;
            radius = 0.0007;
          }
          else {
            op = 0.25;
            radius = 0.001;
          }

          //Change circle color
          polygonBarrierSymbol.setColor(new Color([255,0,0,op]));
          //Change circle outline
          polygonBarrierSymbol.setOutline(
            new SimpleLineSymbol(esri.symbol.SimpleLineSymbol.STYLE_SOLID, new Color([255,255,255,0]), 2));

          //console.log([long, lat]);
          var center = new esri.geometry.Point([long, lat]);

          var ring = []; // point that make up the circle
          var pts = 10; // number of points on the circle
          var angle = 360 / pts; // used to compute points on the circle
          for(var i = 1; i <= pts; i++) {
            // convert angle to raidans
            var radians = i * angle * Math.PI / 180;
            // add point to the circle
            ring.push([center.x + radius * Math.cos(radians), center.y + radius * Math.sin(radians)]);

            //
            //console.log("x", center.x + radius * Math.cos(radians));
            //console.log("y", center.y + radius * Math.sin(radians));
          }
          ring.push(ring[0]); // start point needs to == end point
          var circle = new esri.geometry.Polygon(ring);
          var polygonbarrier = new esri.Graphic(circle,polygonBarrierSymbol);
          polygonbarrier.attributes= {barrierType: 1, attr_length : 100
          };
          barriers.push(
            map.graphics.add(
              polygonbarrier)
              // new esri.Graphic(
              //   circle,
              //   polygonBarrierSymbol)
              // )
              );
          //console.log(routeParams.polygonBarriers);
        }
        //Load-in barrier circle(polygon)
        function addCircleBarrier(long, lat, severity) {
          //op as opacity, radius as radius
          var op, radius;
          if(severity == 1) {
            op = 0.15;
            radius = 0.0004;
          }
          else if(severity == 2) {
            op = 0.20;
            radius = 0.0007;
          }
          else {
            op = 0.25;
            radius = 0.001;
          }


          testSymbol = new SimpleMarkerSymbol();
          testSymbol.setAngle(0);
          testSymbol.setColor(new Color([220, 20, 60, .1]));
          testSymbol.setStyle(SimpleMarkerSymbol.STYLE_CIRCLE);
          testSymbol.setSize(10);

          var xyUnits = webMercatorUtils.lngLatToXY(long, lat);
          var pt = new Point(xyUnits[0],xyUnits[1],map.spatialReference);

          barriers.push(
            map.graphics.add(
              new esri.Graphic(
                pt,
                testSymbol
                )
              )
            );

          plotCount++;
        }
        //Remove all circle(polygon) barriers
        function clearCircleBarrier() {
          removeEventHandlers();
          for (var i=barriers.length-1; i>=0; i--) {
            map.graphics.remove(barriers.splice(i, 1)[0]);
          }
        }

        //Remove all circle(polygon) barriers
        function clearRouteBarrier(givenRouteParameters) {
          removeEventHandlers();
          for (var i=givenRouteParameters.polygonBarriers.features.length-1; i>=0; i--) {
            givenRouteParameters.polygonBarriers.features.splice(i, 1)[0];
          }
        }
        //Stops listening for click events to add barriers and stops (if they've already been wired)
        function removeEventHandlers() {
          if (mapOnClick_addStops_connect) {
            mapOnClick_addStops_connect.remove();
          }
          if (mapOnClick_addBarriers_connect) {
            mapOnClick_addBarriers_connect.remove();
          }
          if (mapOnClick_addPolygonBarriers_connect) {
            mapOnClick_addPolygonBarriers_connect.remove();
          }
          if (myLocationToAddress_connect) {
            myLocationToAddress_connect.remove();
          }
          $("#myLocation").off('click', inputAddress);

        }

        function syncRouteWB(routeStops) { //With Barriers

          console.log(routeStops);

          var stops = [[routeStops[0].geometry.x,routeStops[0].geometry.y],[routeStops[1].geometry.x,routeStops[1].geometry.y]];

          var polygonBarriersURL= "{\"features\":[";

          for(var i = 0; i< barriers.length; i++){

            polygonBarriersURL += "{\"geometry\":{\"rings\":[[";
            for(var j = 0; j < 5/*barriers[i].geometry.rings[0].length*/; j++){
              polygonBarriersURL += "["+barriers[i].geometry.rings[0][j][0]+","+barriers[i].geometry.rings[0][j][1]+"]";
               if(j<4){
                polygonBarriersURL += ",";
               }
             }
             polygonBarriersURL += "]]},\"attributes\":{\"BarrierType\":1,\"Attr_TravelTime\":"+barriers[i].attributes.Attr_TravelTime+"}}";
             if(i<barriers.length-1){
              polygonBarriersURL += ",";
            }
          }
          polygonBarriersURL += "]}";

          polygonBarriersURL= "polygonBarriers=" + polygonBarriersURL;

          var finalSynchronousBarriersURL = 'http://route.arcgis.com/arcgis/rest/services/World/Route/NAServer/Route_World/solve?'+walkModeUrl+'token='+globalToken+'&stops='+stops[0][0]+','+stops[0][1]+';'+stops[1][0]+','+stops[1][1]+"&"+ polygonBarriersURL+'&f=json&returnPolygonBarriers=true';

          $.ajax({
            type: 'POST',
            url: finalSynchronousBarriersURL,


            success: function (results, textStatus, xhr) {
              sRouteWB = JSON.parse(results);
              bypassRouteDirections = JSON.parse(results).directions;
              bypassRoute = new esri.geometry.Polyline(sRouteWB.routes.features[0].geometry.paths[0]);
              routes.push(map.graphics.add(new esri.Graphic(bypassRoute,routeSymbols["Route 2"])));
              $("#BypassRoute").css('display',"inline");
              $("#NormalRoute").css('display',"inline");
              chosenRouteDirections = sRouteWB.directions;
              $("#solveRoute").val('Go!');
            },
            error: function (xhr, textStatus, errorThrown) {
              console.log("test failed");
              console.log("ERROR:" + xhr.responseText + xhr.status + errorThrown);
              return false;
            }
          });

          console.log(routes);
        }

        function chooseBypass(){
          clearRoutes();

          $("#chooseBypass").css("background-color","blue");
          $("#chooseNormal").css("background-color","grey");

          routes.push(map.graphics.add(new esri.Graphic(normalRoute,routeSymbols["Route 1"])));
          routes.push(map.graphics.add(new esri.Graphic(bypassRoute,routeSymbols["Route 2"])));
          chosenRouteDirections = bypassRouteDirections;
        }

        function chooseNormal(){
          clearRoutes();

          $("#chooseNormal").css("background-color","blue");
          $("#chooseBypass").css("background-color","grey");

          routes.push(map.graphics.add(new esri.Graphic(bypassRoute,routeSymbols["Route 1"])));
          routes.push(map.graphics.add(new esri.Graphic(normalRoute,routeSymbols["Route 2"])));
          chosenRouteDirections = normalRouteDirections;
        }


        function syncRouteWOB(routeStops) {//Without Barriers
          console.log("without Barriers called");

          var stops = [[routeStops[0].geometry.x,routeStops[0].geometry.y],[routeStops[1].geometry.x,routeStops[1].geometry.y]];

          $.ajax({
            type: 'POST',
            url: 'http://route.arcgis.com/arcgis/rest/services/World/Route/NAServer/Route_World/solve?'+walkModeUrl+'token='+globalToken+'&stops='+stops[0][0]+','+stops[0][1]+';'+stops[1][0]+','+stops[1][1]+'&f=json',

            success: function (results, textStatus, xhr) {
              sRoute = JSON.parse(results);
              normalRouteDirections = JSON.parse(results).directions;
              console.log(sRoute.travelMode);
              normalRoute = new esri.geometry.Polyline(sRoute.routes.features[0].geometry.paths[0]);
              routes.push(map.graphics.add(new esri.Graphic(normalRoute,routeSymbols["Route 1"])));

              for(var i = 0 ; i < sRoute.directions[0].features.length; i++)
              {
                //console.log(sRoute.directions[0].features[i].attributes.text); shows written directions
              };


            },
            error: function (xhr, textStatus, errorThrown) {
              console.log("test failed");
              console.log("ERROR:" + xhr.responseText + xhr.status + errorThrown);
              return false;
            }
          });

        }

        //Solves the routes. Any errors will trigger the errorHandler function.
        function solveRoute() {
            removeEventHandlers();
            console.log(routeStops);
            syncRouteWOB(routeStops);
            syncRouteWB(routeStops);

            //routeTask.solve(routeParams);
        }
        //Clears all routes
        function clearRoutes() {

          for (var i=routes.length-1; i>=0; i--) {
            map.graphics.remove(routes.splice(i, 1)[0]);
          }
        }

        //Draws the resulting routes on the map
        function showRoute(evt) {

            console.log(evt.result.routeResults);
            clearRoutes();
            array.forEach(evt.result.routeResults, function(routeResult, i) {
              routes.push(
                map.graphics.add(
                  routeResult.route.setSymbol(routeSymbols[routeResult.routeName])
                  )
                );
            });

            console.log(map.graphics);


            var msgs = ["Server messages:"];
            array.forEach(evt.result.messages, function(message) {
              msgs.push(message.type + " : " + message.description);
            });

          var solveResult = evt.result;
          routeResults = solveResult.routeResults;
          //console.log(routeResults[0].directions);
          console.log("The total drive time is " + routeResults[0].directions.totalDriveTime);
          console.log("The total length is " + routeResults[0].directions.totalLength);
          console.log("The total time is " + routeResults[0].directions.totalTime);
        }
        //Reports any errors that occurred during the solve
        function errorHandler(err) {
          alert("An error occured\n" + err.message + "\n" + err.details.join("\n"));
        }
        //Clear all
        function clearAll() {
          clearStops();
          clearBarriers();
          clearCircleBarrier();
        }
        map.on("load", function() {
          // Create street lights
          var featureLayer = new esri.layers.FeatureLayer("http://services1.arcgis.com/p84PN4WZvOWzi2j2/arcgis/rest/services/StreetLights/FeatureServer/0",{
            mode: esri.layers.FeatureLayer.MODE_ONDEMAND,
            outFields: ["*"]
          });
          map.addLayer(featureLayer);
          //Default
          // showBufferZones();
        });
        function showBufferZones(dataz) {
          console.log("showBufferZones() called");
          clearAll();
          for (var i = 0; i < dataz.length; i = i+4) {
           addCircleBarrier1(dataz[i+2], dataz[i+1], dataz[i+3]);
         }
         plotCount = 0;
       }

       function dangerAlgorithm(dataz) {

        var calculatedArray = [];

        var xmin=SantaMonicaCoordinates.xmin;
        var xmax=SantaMonicaCoordinates.xmax;
        var ymax=SantaMonicaCoordinates.ymax;
        var ymin=SantaMonicaCoordinates.ymin;

        var xcells = Math.ceil((xmax-xmin)/SantaMonicaCoordinates.blockWidthXY); //defines how many 300' sections in x direction
        var ycells = Math.ceil((ymax-ymin)/SantaMonicaCoordinates.blockWidthXY); //defines how many 300' sections in y direction

        var longLatTL = webMercatorUtils.xyToLngLat(xmin, ymax, true); //converts the top left xy coordinate into longitude and latitude
        var longLatRB = webMercatorUtils.xyToLngLat(xmax, ymin, true); //converts the right bottom xy coordinate into longitude and latitude
        //console.log(longLatTL); //shows it to make sure it reflects reality
        //console.log(longLatRB); //shows it to make sure it reflects reality

        var xdata;
        var ydata;
        var pointWeight;
        var weightCollection=[];

        var xval;
        var yval;
        var wval;

        //This reflects how far the center of each cell is from eachother, in terms of [longitude, latitude]. This is approximate since earth is round
        var deltaLngLat = [(-longLatTL[0]+longLatRB[0])/xcells,(-longLatRB[1]+longLatTL[1])/ycells];

        for(var i = 0; i < xcells; i++){
          calculatedArray.push([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);//had problems getting array not to point to same object, just added 0's so that I knew for sure they wouldn't be pointing at the same array;

        }


        for(var j = 0; j < dataz.length; j++){ //this calculates each of the xcell/ycell combos that are going to get a point added.
          xdata = Math.round((dataz[j][2]-longLatTL[0])/deltaLngLat[0]); //represents the x coordinate of the grid.  This represents which ycell column we are looking at
          ydata = Math.round((longLatTL[1]-dataz[j][1])/deltaLngLat[1]); //represents the y coordinate of the grid.  This represents which element in the ycell column we are referring to
          pointWeight = dataz[j][3];//This is the weight of the point we are looking at

          if(xdata<42 && xdata>=0 && ydata<36 && ydata>=0){
          	weightCollection.push([xdata,ydata,pointWeight]);//sets up an array that designates which cell the severity weight (included as well) will be added to, while making sure it fits in the extents of the calculated array
          }
      }

      var maxValue = 0
          for(var m = 0; m < weightCollection.length; m++) {
          	xval = weightCollection[m][0];
          	yval = weightCollection[m][1];
          	wval = weightCollection[m][2];
          	calculatedArray[xval][yval] += wval;//If you want to just count the crimes in the area, change wval to 1;
          	if(calculatedArray[xval][yval]>maxValue){
          		maxValue = calculatedArray[xval][yval];
          	}
          }
            return calculatedArray;
          }


          function crimeCluster(dataz){

          	var calculatedArray = [];


          	var xmin=SantaMonicaCoordinates.xmin;
          	var xmax=SantaMonicaCoordinates.xmax;
          	var ymax=SantaMonicaCoordinates.ymax;
          	var ymin=SantaMonicaCoordinates.ymin;

          	var xcells = Math.ceil((xmax-xmin)/SantaMonicaCoordinates.blockWidthXY); //defines how many 300' sections in x direction

          	var ycells = Math.ceil((ymax-ymin)/SantaMonicaCoordinates.blockWidthXY); //defines how many 300' sections in y direction

          	var longLatTL = webMercatorUtils.xyToLngLat(xmin, ymax, true); //converts the top left xy coordinate into longitude and latitude

          	var longLatRB = webMercatorUtils.xyToLngLat(xmax, ymin, true); //converts the right bottom xy coordinate into longitude and latitude

          	var pointDistance;
          	var pointWeight;

          	var minValue;
          	var cellLong;
          	var cellLat;
          	var wval;
          	var testSpatialWeight = [];

          	//This reflects how far the center of each cell is from eachother, in terms of [longitude, latitude]. This is approximate since earth is round

          	var deltaLngLat = [(-longLatTL[0]+longLatRB[0])/xcells,(-longLatRB[1]+longLatTL[1])/ycells];

          	for(var i = 0; i < xcells; i++){
          		calculatedArray.push([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);//had problems getting array not to point to same object, just added 0's so that I knew for sure they wouldn't be pointing at the same array;
          	}

          	//console.log(calculatedArray);


          	for(var i = 0; i < xcells; i++){
          		cellLong = i * deltaLngLat[0] + .5 * deltaLngLat[0];
          		for(var k = 0; k < ycells; k++){
          			cellLat = k * deltaLngLat[1] + .5 * deltaLngLat[1];
          			for(var j = 0; j < 1/*dataz.length*/; j++){
          				pointDistance = Math.pow(Math.pow((cellLong-dataz[j][2]),2)+Math.pow((cellLat-dataz[j][1]),2),.5);
          				calculatedArray[i][k] += dataz[j][3]/pointDistance;
          			}
          			if(i==0 & k==0){
          				minValue = calculatedArray[0][0];
          			}
          			if(calculatedArray[i][k]<minValue){
          				minValue = calculatedArray[i][k];
          				//console.log(minValue);
          			}
          		}
          	}

          	for(var i = 0; i < xcells; i++){
          		for(var k = 0; k < ycells; k++){
          			calculatedArray[i][k] -= minValue;
          		}
          	}
          	return calculatedArray;
          }

          function testCrime(evt) {
            var longLatEvt = webMercatorUtils.xyToLngLat(evt.mapPoint["x"], evt.mapPoint["y"], true);
            var xcell = Math.round((longLatEvt[0]-globalxydata[1][0])/globalxydata[0][0]);
            var ycell = Math.round((globalxydata[1][1]-longLatEvt[1])/globalxydata[0][1]);
            //console.log(crimeArray[xcell][ycell]);
            //console.log("The longitude is " + longLatEvt[0] + ",latitude is " + longLatEvt[1] );
          }


          function showIcons() {
            //console.log("showIcons() called");
            clearAll();
          //Create a new PictureMarkerSymbol based on the static image and set a few properties.
          //Change url to customize
          // Create barriers
          barrierSymbol = new esri.symbol.PictureMarkerSymbol({
            "angle": 0,
            "xoffset": 0,
            "yoffset": 12,
            "type": "esriPMS",
            "url": "http://static.arcgis.com/images/Symbols/Basic/YellowStickpin.png",
            "contentType": "image/png",
            "width": 24,
            "height": 24
          });
          //console.log("showIcons() middle");
          for (var i = 0; i < data.length; i = i+4) {
            //if(data[i+3] > 2) {
              console.log(data[i+2]+', '+data[i+1]+'\n');
              barriers.push(
                map.graphics.add(
                  new esri.Graphic(
                    new esri.geometry.Point(data[i+1], data[i+2]),
                    barrierSymbol
                    )
                  )
                );
            //}
          }
        }
      });
    </script>

  </head>
  <body>

    <div class="row">
      <div class="nav-bar large-12 columns">
				<div><a data-open="callPolicePopup"><img class='icon-wrapper' src="/images/call_icon.png" /></a></div>
				<div><h1 style='margin-top:10px;'>Bypass</h1></div>
				<div><a data-open="infoPopup"><img class='icon-wrapper' src="/images/info_icon.png" /></a></div>
      </div>
    </div>

    <div class="row">
      <div class="filter-directions-nav-bar large-12 columns">
				<div class="row">
					<div class="small-6 large-6 columns">
            <button id='filterButton'><span>Filter</span></button>
          </div>
					<div class="small-6 large-6 columns">
            <button id='directionsButton'><span>Directions</span></button>
          </div>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="directions-nav-bar large-12 columns">
				<form action="addressLookup">
					<div class="row">
						<div class="large-12 columns">
					  	<input class='directions-textbox' type="text" name="startAddress" id="startAddress" placeholder='Choose your starting point'>
						</div>
					</div>
          <div class="row">
						<div id="directionsDisplay" class="large-12 columns"></div>
          </div>
					<div class="row">
						<div class="large-12 columns">
					  	<input class='directions-textbox' type="text" name="destinationAddress" id="destinationAddress" placeholder='Choose your destination'>
						</div>
					</div>
				</form>

      </div>
    </div>

    <input type="button" style='position:absolute; right:0; top:150px; z-index:10; display:none;' class='button radius' value="Solve!" id="solveRoute">

    <div class="row">
      <div id='map_row' class="large-12 columns">
        <div id="map"></div>

        <div id="rightControlPanel">
          <button id="clearRoutesBtn" class='button' style='right:0; top:250px; position:absolute;'>Clear Screen</button>
          <button id="DensityGrid" class='button' style='right:0; top:200px; position:absolute;'>Density Grid</button>

      </div>
    </div>

    <div class='bottomRightNav'>
      <button class='button radius' id="BypassRoute" style="display:none;"><span>Bypass</span></button>
      <button class='button radius' id="NormalRoute" style="display:none;"><span>Normal</span></button>
      <button class='button radius' id="cancel">Cancel</button>
      <a class='button radius' id="myLocation"><img src='../images/crosshair.png'></img></a>
      <div id="GPSdiv" style="display:none;"></div>
    </div>

    <div class="reveal" id="callPolicePopup" data-reveal>
      <a class='button alert radius' href="tel:911">Call Police<a></a>
      <button class="close-button" data-close aria-label="Close modal" type="button">
        <span aria-hidden="true">&times;</span>
      </button>
    </div>

    <div class="reveal" id="infoPopup" data-reveal>
      <p>Bypass will help you get from A-B using the safest route. Enter your Destination in the 'End Location' bar and the beginning location in the 'Start Location' bar. You can use the filter button to alter the types of historical crimes you will void, see landmarks, well let streets, a heat map of crimes and filter the date of the historical incidents. Pressing the directions button will give you written directions to your desired locations. The 'Red Call' button will call the police and send a message to your allocated emergency contact.</p>
      <button class="close-button" data-close aria-label="Close modal" type="button">
        <span aria-hidden="true">&times;</span>
      </button>
    </div>

    <script src="javascripts/app.js"></script>
  </body>
</html>
